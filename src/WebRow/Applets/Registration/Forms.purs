module WebRow.Applets.Registration.Forms where

-- import Prelude
-- 
-- import Data.Maybe (Maybe(..))
-- import Data.Newtype (un)
-- import Data.String (Pattern(..), contains) as String
-- import Data.Validation.Semigroup (invalid)
-- import Polyform.Batteries (error) as Batteries
-- import Polyform.Batteries.UrlEncoded.Duals (singleValue) as UrlEncoded.Validators.Duals
-- import Polyform.Batteries.UrlEncoded.Validators (singleValue) as UrlEncoded.Validators
-- import Polyform.Dual (dual, dual') as Dual
-- import Polyform.Validator (check, checkM, liftFn, liftFnV) as Validator
-- import Polyform.Validator.Dual (check) as Validator.Dual
-- import Type.Prelude (SProxy(..))
-- import WebRow.Applets.Auth.Forms (checkPassword) as Auth.Forms
-- import WebRow.Applets.Auth.Types (Password(..))
-- import WebRow.Applets.Registration.Effects (emailTaken) as Effects
-- import WebRow.Forms.Dual ((~))
-- import WebRow.Forms.Dual (Form(..), textInput) as Forms.Dual
-- import WebRow.Forms.Fields.Duals (email) as Fields.Duals
-- import WebRow.Forms.Fields.Validators (email) as Fields.Validators
-- import WebRow.Forms.Plain (input, passwordField, sectionValidator) as Forms.Plain
-- 
-- _emailTaken = SProxy ∷ SProxy "emailTaken"
-- 
-- emailTakenValidator = Validator.checkM
--   (Batteries.error _emailTaken)
--   Effects.emailTaken
-- 
-- _email = SProxy ∷ SProxy "email"
-- 
-- emailForm = Forms.Plain.input "" _email validator
--   where
--     validator = UrlEncoded.Validators.singleValue >>> Fields.Validators.email >>> emailTakenValidator
-- 
-- _passwordsDontMatch = SProxy ∷ SProxy "passwordsDontMatch"
-- 
-- passwordForm = passwordsForm >>> Forms.Plain.sectionValidator validator
--   where
--     validator = Validator.liftFn (Password <<< _.password1) <<< Validator.check
--       (Batteries.error _passwordsDontMatch)
--       (\r → r.password1 /= r.password2)
-- 
--     passwordsForm = { password1: _, password2: _ }
--       <$> Forms.Plain.passwordField
--       <*> Forms.Plain.passwordField
-- 
-- _sameEmail = SProxy ∷ SProxy "sameEmail"
-- 
-- -- | This an example of "Forms.Dual.Form"
-- -- | we are going to drop it from here
-- -- | as bidirectionallity is not necessary
-- -- | in this case (we don't have to fill email value) :-P
-- updateEmailForm email = Forms.Dual.Form $
--   identity ~ Forms.Dual.textInput "" "email" dual
--   <* (const "") ~ Auth.Forms.checkPassword email
--   where
--     emailDiffers = Validator.Dual.check
--       (Batteries.error _sameEmail)
--       (not <<< eq email)
-- 
--     dual = UrlEncoded.Validators.Duals.singleValue >>> Fields.Duals.email >>> emailDiffers >>> Dual.dual' emailTakenValidator
